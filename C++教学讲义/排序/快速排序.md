

## 定义

快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」，是一种被广泛运用的排序算法。


## 基本原理与实现

### 过程

快速排序的工作原理是通过 **分治** 的方式来将一个数组排序。

快速排序分为三个过程：

**1.  将数列划分为两部分（要求保证相对大小关系：左小右大）；
2.  递归到两个子序列中分别进行快速排序；
3.  不用合并，因为此时数列已经完全有序。**

和归并排序不同，第一步并不是直接分成左右两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数 `mid`来当做两个子数列的分界。

**具体步骤如下：**
1. 随机选择一个数 `mid`当做分界值
2. 维护一前一后两个指针`i`  和 `j`。
3. `i`从数列最左边开始扫描，找到一个比`mid`大的数则暂停；`j`从数列最右边开始扫描，找到一个比`mid`小的数则暂停
4. 若`i`和`j`没相遇，则将`i`和`j`对应的元素交换位置，并将`i`的扫描位置右移一位，将`j`的扫描位置左移一位，继续扫描。
5. 直到`i`的扫描位置跑到`j`右侧后，当前扫描结束。
6. 对左右两部分数列递归调用1-5

其实，快速排序没有指定应如何具体实现第一步，不论是选择  `mid` 的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

### 代码实现
```cpp
void qsort(int a[], int l, int r){
	int i = l, j = r, mid;
	// 将当前序列在中间位置的数定义位分隔数
	mid = a[(l+r)/2];
	// 注意，while条件里必须要有等号，目的是为了使左右两部分区间[l,j]和[i,r]没有重叠区域
	while(i<=j){
		// 左半部分寻找比中间数大的数
		while(a[i]<mid) i++;
		// 右半部分寻找比中间数小的数
		while(a[j]>mid) j--;
		// 找到一组与排序目标不一致的数，则交换他们
		if (i<=j){
			swap(a[i], a[j]);
			// 继续往后扫描
			i++;
			j--;
		}
	}
	
	if(l<j) qsort(a, l, j);
	if(i<r) qsort(a, i, r);

}
```

## 性质
### 稳定性
快速排序是一种不稳定的排序算法。相同大小的数在排序前后相对位置可能产生变化。

### 时间复杂度
快速排序的最优时间复杂度和平均时间复杂度为  $O(n*log{n})$，最坏时间复杂度为 `O(n^2)`。



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3MTE4MTQ5LDExODY4MjI4MDAsMjAzNj
gyNTc5MiwtMTU2NTYyODE1Nl19
-->