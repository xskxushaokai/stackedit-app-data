
# 二分查找模板函数

## lower_bound
**查找第一个等于或大于x的元素**

## upper_bound
**查找第一个大于x的元素**

## 常用示例

```cpp
#include<iostream>
#include<algorithm>

int idx_l = lower_bound(a, a+n, x) - a  // 查找第一个大于等于x的元素
int idx_u = upper_bound(a, a+n, x) - a  // 查找第一个大于x的元素

// 第一个等于x的元素
if(a[idx_l]==x) cout << idx_l;

// 查找最后一个等于x的元素
if(a[idx_u-1]==x) cout << idx_u - 1;

// 查找最后一个等于或小于x的元素
cout << idx_u - 1;

// 查找最后一个小于x的元素
cout << idx_l - 1;

// 计算序列中x的个数
cout << idx_u - idx_l;

```

---
# 题解

## 例1.  P2440 木材加工

## 题目背景

要保护环境。

## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。

## 输入格式

第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。

接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。

## 输出格式

仅一行，即 $l$ 的最大值。

如果连 $\text{1cm}$ 长的小段都切不出来，输出 `0`。

## 输入输出样例 #1

### 输入 #1

```
3 7
232
124
456
```

### 输出 #1

```
114
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。

## 分析
```cpp
// n条木头长度a[n],切成长度为x的小段，可以切s段
// 单调递减函数，满足二分查找的前提
for(int i=0;i<n;i++) 
	s += a[i]/x;   

// 二分查找[minl,maxl]，假设切成长度为mid的小段，可切s段
// 核心：当s==k时，需要进一步查找，向右查找， 因为目标是找最大的切割长度，s==k时，木头有可能有剩余残段
```

**完整代码**
```cpp
#include<iostream>

using namespace std;
const int MINL = 0;

int a[100005];
int n, k;

int bin_search(int minl, int maxl){
    while(minl<=maxl){
        int mid = (minl+maxl)/2;
        int s = 0;
        for(int i=0;i<n;i++) s += a[i] / mid;    // 单调递减函数

		// 核心：当s==k时，需要进一步查找，向右查找， 因为目标是找最大的切割长度，s==k时，木头有可能有剩余残段 
        if (s>=k) minl = mid + 1;
        else maxl = mid - 1;    // 不够切k段，就往左边找 
    }
    return minl;  // 得到的是等于或大于最大切割的长度，因为 if (s>=k) minl = mid + 1;
}

int main(){
    cin >> n >> k;
    int maxl = MINL;
    for(int i=0;i<n;i++) {
        cin >> a[i];
        if (a[i]>maxl) maxl = a[i];
    }

    int ans = bin_search(1, maxl);
    // printf("search结果:%d\n", ans);
    
    int s = 0;
    for(int i=0;i<n;i++) s += a[i] / ans;
    // printf("切出的段数:%d\n", s);
    if (s<k) cout << ans-1;
    else cout << ans;
    
    return 0;
}
```

---

## 例2. P1024 [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 输入格式

一行，$4$ 个实数 $a, b, c, d$。

## 输出格式

一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。

## 输入输出样例 #1

### 输入 #1

```
1 -5 -4 20
```

### 输出 #1

```
-2.00 2.00 5.00
```

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 分析
题目给的条件：**存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），根与根之差的绝对值 $\ge 1$**。这意味着，$[-100,100]$区间内的某个整数$i$，仅存在一个根属于区间$[i,i+1)$，这样的 $i$有三个，所以我们只需要将区间$[-100,100]$划分为长度为1的小区间，依次判断每个区间内是否存在一个根。

如何判断小区间内是否存在根呢？刚才我们已经根据题意推断出，小区间内至多只有$1$个根，所以，如果该区间有且仅有$1$个根（$f(x)=0$），则这个区间的左右两个端点处的函数值符号必定相反（$f(left)*f(right)<0$）。故我们仅需要在满足$f(left)*f(right)<0$的小区间内寻找根即可。小区间内寻找根直接使用实数二分查找即可，判断$f(mid)$值与$f(left)$、$f(right)$符号是否相异（即$f(mid)$与$f(left)$、$f(right)$的乘积是否小于$0$），将根的查找范围缩小到符号相异的小区间内即可。直到查找区间的长度缩小到满足精度要求（**题目要求精确到0.01，则查找时的区间需要缩小到0.001以内，四舍五入之后才能精确到0.01**），则端点值就是我们要找的根。

```cpp
#include<iostream>
using namespace std;

double a,b,c,d;
double fun(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}

double bin_search(double l, double r){
    // 实数二分，左闭右开，找到一个即可提前返回，否则缩小查找区间，直到满足精度要求
    while(r-l>0.001){
        double mid = (l+r)/2.0;
        double f_mid = fun(mid);
        if(f_mid==0) return mid;
        else if(f_mid*fun(l)<0){
            r = mid;
        }
        else{
            l = mid + 0.001;
        }
    }
    return l;
}

int main(){
    cin >> a >> b >> c >> d;

    // -100到100之间枚举所有端点值
    double left, right, res;
    left = fun(-100);
    for(int i=-99;i<=100;i++){
        right = fun(i);
        if(left==0) printf("%.2f ", (double)i-1);    // 特判根为左端点
        else if(left*right < 0){
            // 在[i-1,i)区间查找根
            res = bin_search((double)i-1, (double)i);
            printf("%.2f ", res);
        }

        left = right;
    }

    return 0;
}
```
---

## 例3. P1163 银行贷款

## 题目描述

当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。

## 输入格式

三个用空格隔开的正整数。

第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。

## 输出格式

一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\%$。

数据保证答案不超过 $300.0\%$。

## 输入输出样例 #1

### 输入 #1

```
1000 100 12
```

### 输出 #1

```
2.9
```

## 说明/提示

数据保证，$1 \leq w_0, w\leq 2^{31}-1$，$1 \leq m\leq 3000$。


## 分析
**贷款计算解读：** 何为利率按月累计？即我们常说的**等额本息** 还款方式，假如贷款总额为$w_0$，要还$n$个月，利率为$r$，每月还款额为$w$，则第一个月还款后剩余本息应还总额为：$w0_*(1+r)-w$，第二个月还款后剩余本息应还总额为：$(w0_*(1+r)-w)*(1+r)-w$，第三个月还款后剩余本息应还总额为：$((w0_*(1+r)-w)*(1+r)-w)*(1+r)-w$，。。。。。。直到第$n$个月后，剩余应该本息总额为$0$。

题目给定了贷款总额$w_0$，每月还款额$w$、还款月数$m$，求贷款利率。故我们只需要在利率范围内进行搜索，找到一个利率r，使得根据上述计算方法，$m$个月后，剩余应还总额刚好为0.

**二分查找即可**

**定义计算m个月后剩余应还总额的函数**，该函数为**单调递增函数**，故满足二分查找前提。
```cpp
// 单调递增函数
double fun(int w0, int w, int m, double r){
    double w0_ = (double)w0;
    while(m--) w0_ = w0_*(1+r)-w;
    return w0_;
}
```
**完整代码**
```cpp
#include<iostream>

using namespace std;

int w0, w, m;

// 单调递增函数
double fun(int w0, int w, int m, double r){
    double w0_ = (double)w0;
    while(m--) w0_ = w0_*(1+r)-w;
    return w0_;
}

double bin_search(double left, double right){
    while(right-left>0.0001){
        double mid = (left+right)/2.0;
        double alpha = fun(w0,w,m,mid);
        // cout << mid << " mid " << alpha << endl;
        // cout << left << " left " << fun(w0,w,m,left) << endl;

        if (alpha==0) return mid;
        else if (alpha*fun(w0,w,m,left)<=0) right = mid;
        else left = mid;
    }
    return left;
}

int main(){
    cin >> w0 >> w >> m;
    double res = bin_search(0, 3)*100;
    printf("%.1f\n", res);
    
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NTQxODQ2MTMsMTc0NjcyMjY0NywyMD
g1OTkzODksLTE0NTY5NjYyMTgsLTUzMDkxNDEzOCwxMzUzODcz
OTUwLDE0MTE3NjA0MzQsMTU1MTg5NTQ0LC0xNDQyODMxMDgzLC
04OTQxMjI1ODMsLTM2MTk2ODEyOV19
-->