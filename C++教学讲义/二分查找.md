
# 二分查找模板函数

## lower_bound
**查找第一个等于或大于x的元素**

## upper_bound
**查找第一个大于x的元素**

## 常用示例

```cpp
#include<iostream>
#include<algorithm>

int idx_l = lower_bound(a, a+n, x) - a  // 查找第一个大于等于x的元素
int idx_u = upper_bound(a, a+n, x) - a  // 查找第一个大于x的元素

// 第一个等于x的元素
if(a[idx_l]==x) cout << idx_l;

// 查找最后一个等于x的元素
if(a[idx_u-1]==x) cout << idx_u - 1;

// 查找最后一个等于或小于x的元素
cout << idx_u - 1;

// 查找最后一个小于x的元素
cout << idx_l - 1;

// 计算序列中x的个数
cout << idx_u - idx_l;

```

---
# 题解

## 例1.  P2440 木材加工

## 题目背景

要保护环境。

## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。

## 输入格式

第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。

接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。

## 输出格式

仅一行，即 $l$ 的最大值。

如果连 $\text{1cm}$ 长的小段都切不出来，输出 `0`。

## 输入输出样例 #1

### 输入 #1

```
3 7
232
124
456
```

### 输出 #1

```
114
```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。

## 分析
```cpp
// n条木头长度a[n],切成长度为x的小段，可以切s段
// 单调递减函数，满足二分查找的前提
for(int i=0;i<n;i++) 
	s += a[i]/x;   

// 二分查找[minl,maxl]，假设切成长度为mid的小段，可切s段
// 核心：当s==k时，需要进一步查找，向右查找， 因为目标是找最大的切割长度，s==k时，木头有可能有剩余残段
```

**完整代码**
```cpp
#include<iostream>

using namespace std;
const int MINL = 0;

int a[100005];
int n, k;

int bin_search(int minl, int maxl){
    while(minl<=maxl){
        int mid = (minl+maxl)/2;
        int s = 0;
        for(int i=0;i<n;i++) s += a[i] / mid;    // 单调递减函数

		// 核心：当s==k时，需要进一步查找，向右查找， 因为目标是找最大的切割长度，s==k时，木头有可能有剩余残段 
        if (s>=k) minl = mid + 1;
        else maxl = mid - 1;    // 不够切k段，就往左边找 
    }
    return minl;  // 得到的是等于或大于最大切割的长度，因为 if (s>=k) minl = mid + 1;
}

int main(){
    cin >> n >> k;
    int maxl = MINL;
    for(int i=0;i<n;i++) {
        cin >> a[i];
        if (a[i]>maxl) maxl = a[i];
    }

    int ans = bin_search(1, maxl);
    // printf("search结果:%d\n", ans);
    
    int s = 0;
    for(int i=0;i<n;i++) s += a[i] / ans;
    // printf("切出的段数:%d\n", s);
    if (s<k) cout << ans-1;
    else cout << ans;
    
    return 0;
}
```

---

## 例2. P1024 [NOIP 2001 提高组] 一元三次方程求解

## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。

## 输入格式

一行，$4$ 个实数 $a, b, c, d$。

## 输出格式

一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。

## 输入输出样例 #1

### 输入 #1

```
1 -5 -4 20
```

### 输出 #1

```
-2.00 2.00 5.00
```

## 说明/提示

**【题目来源】**

NOIP 2001 提高组第一题

## 分析
题目给的条件：**存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），根与根之差的绝对值 $\ge 1$**。这意味着，$[-100,100]$区间内的某个整数$i$，存在一个根属于区间$[i,i+1]$，这样的 $i$有三个，

```cpp
#include<iostream>
using namespace std;

double a,b,c,d;
double fun(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}

double bin_search(double l, double r){
    // 实数二分，左闭右开，找到一个即可提前返回，否则缩小查找区间，直到满足精度要求
    while(r-l>0.001){
        double mid = (l+r)/2.0;
        double f_mid = fun(mid);
        if(f_mid==0) return mid;
        else if(f_mid*fun(l)<0){
            r = mid;
        }
        else{
            l = mid + 0.001;
        }
    }
    return l;
}

int main(){
    cin >> a >> b >> c >> d;

    // -100到100之间枚举所有端点值
    double left, right, res;
    left = fun(-100);
    for(int i=-99;i<=100;i++){
        right = fun(i);
        if(left==0) printf("%.2f ", (double)i-1);    // 特判根为左端点
        else if(left*right < 0){
            // 在[i-1,i)区间查找根
            res = bin_search((double)i-1, (double)i);
            printf("%.2f ", res);
        }

        left = right;
    }

    return 0;
}
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA4NTk5Mzg5LC0xNDU2OTY2MjE4LC01Mz
A5MTQxMzgsMTM1Mzg3Mzk1MCwxNDExNzYwNDM0LDE1NTE4OTU0
NCwtMTQ0MjgzMTA4MywtODk0MTIyNTgzLC0zNjE5NjgxMjldfQ
==
-->