# 队列

## 引入

队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

## 性质
队列具有如下性质：
1. 新元素只能从队尾插入；
2. 删除元素只能从队头删除；

## 数组模拟队列

通常用一个数组模拟一个队列，用两个变量作为队列的**首指针**和**尾指针**，**首指针和尾指针之间的元素认为是在队列中的元素**。
```cpp
// 初始化一个空队列
int q[SIZE], front=0, tail=0;
```
队列操作对应的代码如下：

-   插入元素：
```cpp
// 将新元素插入到队尾，队尾指针向后移
q[tail] = x; 
tail++;
```
-   删除元素：
```cpp
// 队头指针后移
front++;
```
-   访问队首元素：
```cpp
q[front]
```
-   访问队尾：
```cpp
q[tail]
```
-   判断队空：
```cpp
front==tail;
```

## 循环队列
使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为「**假溢出**」）。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 `x` 的元素，它的后继为 `(x + 1) % SIZE`）。这样就形成了循环队列。

**循环队列 插入元素和删除元素操作为：**
```cpp
// 将新元素插入到队尾，队尾指针向后移,SIZE为实际用到数组的长度
q[tail] = x; 
tail = (tail+1) % SIZE;
```
```cpp
// 删除元素,队头指针后移
front = (front+1) % SIZE;
```

## 例1 周末舞会
假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队（队头的男士和女士编号为1）。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲能有一对跳舞者。若两队初始人数不相同则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。

输入：第一行两队的人数$n$和$m$第二行舞曲的数目$k$
输出：k行，每行为每个舞曲配对的男士和女士编号

**【分析】**
设计两个循环队列分别存放男士和女士，每队跳舞的人一旦跳完后就回到队尾等待下次被选。

**【参考程序】**
```cpp
#include<iostream>
using namespace std;
int a[10001], b[10001], k, f1=0,r1, f2=0,r2;
int main(){
	int m, n;
	cin>>m>>n>>k;
	for(int i=0;i<m;i++) a[i] = i+1;
	for(int i=0;i<n;i++) a[i] = i+1;
	
	// 数据放在在a数组的[0,m-1],b数组的[0,n-1]中，队头指向0，队尾指向m和n（即最后一个元素的下一个位置）
	r1 = m;
	r2 = n;
	
	int j=0;
	while(j<k){
		printf("%d %d\n", a[f1], b[f2]);
		a[r1] = a[f1];
		r1 = (r1+1)%(m+1);
		f1 = (f1+1)%(m+1);
		b[r2] = b[f2];
		r2 = (r2+1)%(n+1);
		f2 = (f2+1)%(n+1);
		j++;
	}

	return 0;
}
```

## 例2 P1996 约瑟夫问题
### 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

### 输入格式

输入两个整数 $n,m$。

### 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。

#### 输入样例

```
10 3
```

### 输出样例

```
3 6 9 2 7 1 8 5 10 4
```

### 说明/提示

$1 \le m, n \le 100$

### 【分析】
初始化一个循环队列，报数时，依次将报$[1,m-1]$的人出队并加入到队尾，将报m的人出队并输出，直到队列为空。
### 示例代码
```cpp
#include<iostream>
using namespace std;

int main(){
    int n,m;
    cin>>n>>m;
    int a[n+2], front=1, tail;
    for(int i=1;i<=n;i++) a[i] = i;
    tail = n+1;

    int k=1;
    while(front!=tail){
        if(k==m){ 
            cout << a[front] << " ";
            front = (front+1)%(n+2);
            k = 1;
        }
        else{
            a[tail] = a[front];
            front = (front+1)%(n+2);
            tail = (tail+1)%(n+2);
            k++;
        }
    }
    return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjA4ODg3MjU0LC0xNDM0ODkxNTM5LC0xMD
I1Mjg5NDc0LDQwMzQ0OTQ1NCwtNDA5NzM5MjgxLDI5ODkxMjcy
MywxMzQ0MTQwODk0LDIwNTk3NjYyNDksMTA0NjU2ODk3OV19
-->