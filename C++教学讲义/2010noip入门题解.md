
## 2010 NOIP 入门组题解

### T2

```c++
// 模拟做法，特别注意：接水停止的条件是，所有水龙头上的同学都接完水了，并且没人排队了

#include<iostream>
// #include<numeric>

using namespace std;

int a[10005], pos[105];

int main(){
	// freopen("P1190_9.in", "r", stdin);
	// freopen("P1190_9.out", "w", stdout);

	int n, m, stop=1, cost=0;
	cin >> n >> m;
	int next = m+1; // 下一个轮到的人

	for(int i=1;i<=n;i++) {
		cin >> a[i];
		if (i<=m) pos[i] = i;
	}

	while(1){
		cost++;
		for(int i=1;i<=m;i++){
			if(a[pos[i]]>0) {
				a[pos[i]]--;
				if(a[pos[i]]>0) stop = 0; // 只要有一个水龙头上的同学还没接完水，就继续模拟接水
			}

			// 排队的人补位接水
			if(a[pos[i]]==0 && next<=n){
				pos[i] = next;
				next++;
				stop = 0; // 有人补位上来，继续模拟接水
			}
		}

		if (stop) break;
		stop = 1;

		// if(accumulate(a+1, a+1+n , 0)==0) break;
	}
	cout << cost << endl;
	return 0;
}
```

```c++
// 贪心做法
#include<iostream>

using namespace std;

int a[10005], pos[105];
// 数组a记录每个人要接水的总量
// 数组pos记录 从第1秒开始接水，到新的排队的人开始接水时，每个水龙头接水的总量（也等于每个水龙头接水的时间）

int main(){
	int n, m;
	cin >> n >> m;
	for(int i=1;i<=n;i++) cin >> a[i];
	
	// 遍历n个人，依次给每个人分配水龙头，让下一个排队的人去接水时间最短的水龙头
	for(int i=1;i<=n;i++){
		int minpos = 1;

		// 遍历m个水龙头，找到接水时间最短的水龙头
		for(int j=2;j<=m;j++){
			if(pos[j]<pos[minpos]) minpos = j;
		}
		pos[minpos] += a[i]; // 让第i个人去minpos水龙头接水，将这个人的接水总量加到minpos水龙头的接水总量中
	}

	// n个人都接完水后，找到总接水时间最长的水龙头
	int maxpos = 1;
	for(int j=2;j<=m;j++){
		if(pos[j]>pos[maxpos]) maxpos = j;
	}
	cout << pos[maxpos] << endl;
	return 0;
}
```

### T3
```c++
#include<iostream>
#include<math.h>
#include<algorithm>

using namespace std;

struct Dis{
	int d1, d2;
} rad[100005];

bool cmp(Dis a, Dis b){
	return a.d1 > b.d1;
}

int main(){
	int x_1, y_1, x_2, y_2, N;
	int xd, yd;
	cin >> x_1 >> y_1 >> x_2 >> y_2 >> N;

	for(int i=0;i<N;i++){
		cin >> xd >> yd;
		rad[i].d1 = pow(x_1-xd, 2) + pow(y_1-yd, 2); // 导弹到rad1的距离平方和
		rad[i].d2 = pow(x_2-xd, 2) + pow(y_2-yd, 2); // 导弹到rad2的距离平方和

	}
	
	// 以每个导弹与rad1的距离为准进行排序，从大到小
	sort(rad, rad+N, cmp);

	int min_cost = rad[0].d1; // 第一种情况，全部由rad1拦截，rad2不拦截
	int max_r2 = 0;

	for(int i=1;i<N;i++){
		// printf("%d %d\n", rad[i].d1, rad[i].d2);
		int cost = rad[i].d1 + max(rad[i-1].d2, max_r2);
		min_cost = min(min_cost, cost);
		max_r2 = max(max_r2, rad[i-1].d2);
	}


	// 最后一种情况不要漏掉，rad1不拦截，全部由rad2拦截
	min_cost = min(min_cost, max(max_r2, rad[N-1].d2));
	printf("%d\n", min_cost);

	return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMjE0MDQ3NTEsNzgxNDg0NywxNjI3Nj
YyMzM4LDE1NTMyNzM1NDJdfQ==
-->