
# 2010 NOIP 入门组题解

## T2 P1190接水问题
## 题目描述

学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。

现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。

现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

## 输入格式

第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。

第二行 $n$ 个整数 $w_1,w_2,\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。

## 输出格式

一个整数，表示接水所需的总时间。

## 输入输出样例 #1

### 输入 #1

```
5 3
4 4 1 2 1
```

### 输出 #1

```
4
```

## 输入输出样例 #2

### 输入 #2

```
8 4
23 71 87 32 70 93 80 76
```

### 输出 #2

```
163
```

## 说明/提示

【输入输出样例 \#1 说明】

第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。

第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。

第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。

第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。

【数据范围】

$1 \le n \le {10}^4$，$1 \le m \le 100$，$m \le n$；

$1 \le w_i \le 100$。


```c++
// 模拟做法，特别注意：接水停止的条件是，所有水龙头上的同学都接完水了，并且没人排队了

#include<iostream>
// #include<numeric>

using namespace std;

int a[10005], pos[105];

int main(){
	// freopen("P1190_9.in", "r", stdin);
	// freopen("P1190_9.out", "w", stdout);

	int n, m, stop=1, cost=0;
	cin >> n >> m;
	int next = m+1; // 下一个轮到的人

	for(int i=1;i<=n;i++) {
		cin >> a[i];
		if (i<=m) pos[i] = i;
	}

	while(1){
		cost++;
		for(int i=1;i<=m;i++){
			if(a[pos[i]]>0) {
				a[pos[i]]--;
				if(a[pos[i]]>0) stop = 0; // 只要有一个水龙头上的同学还没接完水，就继续模拟接水
			}

			// 排队的人补位接水
			if(a[pos[i]]==0 && next<=n){
				pos[i] = next;
				next++;
				stop = 0; // 有人补位上来，继续模拟接水
			}
		}

		if (stop) break;
		stop = 1;

		// if(accumulate(a+1, a+1+n , 0)==0) break;
	}
	cout << cost << endl;
	return 0;
}
```

```c++
// 贪心做法
#include<iostream>

using namespace std;

int a[10005], pos[105];
// 数组a记录每个人要接水的总量
// 数组pos记录 从第1秒开始接水，到新的排队的人开始接水时，每个水龙头接水的总量（也等于每个水龙头接水的时间）

int main(){
	int n, m;
	cin >> n >> m;
	for(int i=1;i<=n;i++) cin >> a[i];
	
	// 遍历n个人，依次给每个人分配水龙头，让下一个排队的人去接水时间最短的水龙头
	for(int i=1;i<=n;i++){
		int minpos = 1;

		// 遍历m个水龙头，找到接水时间最短的水龙头
		for(int j=2;j<=m;j++){
			if(pos[j]<pos[minpos]) minpos = j;
		}
		pos[minpos] += a[i]; // 让第i个人去minpos水龙头接水，将这个人的接水总量加到minpos水龙头的接水总量中
	}

	// n个人都接完水后，找到总接水时间最长的水龙头
	int maxpos = 1;
	for(int j=2;j<=m;j++){
		if(pos[j]>pos[maxpos]) maxpos = j;
	}
	cout << pos[maxpos] << endl;
	return 0;
}
```

## T3 P1158 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 输入格式

第一行包含 $4$ 个整数 $x_1,y_1,x_2,y_2$，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为 $(x_1,y_1), (x_2,y_2)$。第二行包含 $1$ 个整数 $N$，表示有 $N$ 颗导弹。接下来 $N$ 行，每行两个整数 $x,y$，中间用一个空格隔开，表示一颗导弹的坐标 $(x,y)$。不同导弹的坐标可能相同。

## 输出格式

一个整数，即当天的最小使用代价。

## 输入输出样例 #1

### 输入 #1

```
0 0 10 0
2
-3 3
10 0
```

### 输出 #1

```
18
```

## 输入输出样例 #2

### 输入 #2

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1
```

### 输出 #2

```
30
```

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

## 分析

求解目标为两个雷达的最小半径平方和，容易想到，可以暴力枚举所有的半径取值，最后找出平方和最小的那组即可。每个导弹到该雷达的距离即为该雷达所有可能的半径取值，故枚举两个雷达的半径时间复杂度是$n^2$，再加上每组半径组合都需要判断每一枚导弹是否能拦截，故总的时间复杂度为$n^3$。根据题目给出的数据规模，需要优化。

很明显，只有两个雷达，所有导弹都要拦截，所以只要雷达1的半径确定后，雷达2的半径就不需要再枚举了，雷达1无法拦截的所有导弹到雷达2的最大距离即为雷达2的半径。枚举雷达1的半径时间复杂度为$n$，再找到剩余未拦截的导弹并计算到雷达2的最大半径 时间复杂度为$n$，总的时间复杂度将为$n^2$。仍然太大，考虑继续优化。

如何优化，雷达1的半径取值与两个雷达的距离平方不是正相关，无法使用二分。无后效性也不满足，动态规划也失效。只能从刚才的思路继续找突破口，有没有办法可以优化找未被雷达1拦截的导弹这个过程呢？根据输入，我们可以将导弹与雷达的距离平方列为下表（最终所求为半径平方，函数$y=x^2$在$[0, ∞)$区间内单调递增，故我们直接使用距离平方即可）：

|导弹与雷达的距离平方 |雷达1|雷达2
|--|--|--|
| 导弹a | 20 | 104 |
| 导弹b | 13 | 73 |
| 导弹c | 16 | 4 |
| 导弹d | 40 | 4 |
| 导弹e | 82 | 10 |

观察上表，导弹a-e到雷达1的距离是无序的，故我们枚举雷达1的半径时，每次枚举都需要再进行一次循环去寻找未被雷达1拦截的导弹，有没有方法可以做到：只要枚举一个雷达1的半径，立马就能知道哪些导弹未被拦截呢？聪明的同学已经想到了，只需要将所有导弹到雷达1的距离进行排序，再按照顺序枚举每个距离作为雷达1的半径，那么大于该距离的导弹均无法被雷达1拦截，这样就解决了**每次枚举都需要再用循环去寻找未被拦截的导弹**的问题了。排序后得到下表：

|导弹与雷达的距离平方 |雷达1|雷达2
|--|--|--|
| 导弹e | 82 | 10 |
| 导弹d | 40 | 4 |
| 导弹a | 20 | 104 |
| 导弹c | 16 | 4 |
| 导弹b | 13 | 73 |

枚举雷达1半径的过程如下：
1. $r1=82$，此时所有导弹都被雷达1拦截，$r2=0，r1^2+r2^2=82$；
2. $r1=40$，此时导弹e未被拦截，$r2=10，r1^2+r2^2=82$；
3. $r1=20$，此时排在导弹a之前的e和d均未被拦截，此时$r2=max(r2,4)=10，r1^2+r2^2=82$;
4. $r1=16$，此时排在导弹c之前的e、d、a未被拦截，此时$r2=max(r2,104)=104，r1^2+r2^2=82$;
5. $r1=13$，此时排在导弹b之前的e、d、a、c未被拦截，此时$r2=max(r2,4)=104，r1^2+r2^2=82$;
6. $r1=0$，此时排在导弹e、d、a、c、b未被拦截，此时$r2=max(r2,73)=104，r1^2+r2^2=82$;


```c++
#include<iostream>
#include<math.h>
#include<algorithm>

using namespace std;

struct Dis{
	int d1, d2;
} rad[100005];

bool cmp(Dis a, Dis b){
	return a.d1 > b.d1;
}

int main(){
	int x_1, y_1, x_2, y_2, N;
	int xd, yd;
	cin >> x_1 >> y_1 >> x_2 >> y_2 >> N;

	for(int i=0;i<N;i++){
		cin >> xd >> yd;
		rad[i].d1 = pow(x_1-xd, 2) + pow(y_1-yd, 2); // 导弹到rad1的距离平方和
		rad[i].d2 = pow(x_2-xd, 2) + pow(y_2-yd, 2); // 导弹到rad2的距离平方和
	}
	
	// 以每个导弹与rad1的距离为准进行排序，从大到小
	sort(rad, rad+N, cmp);

	int min_cost = rad[0].d1; // 第一种情况，全部由rad1拦截，rad2不拦截
	int max_r2 = 0;

	for(int i=1;i<N;i++){
		// printf("%d %d\n", rad[i].d1, rad[i].d2);
		int cost = rad[i].d1 + max(rad[i-1].d2, max_r2);
		min_cost = min(min_cost, cost);
		max_r2 = max(max_r2, rad[i-1].d2);
	}

	// 最后一种情况不要漏掉，rad1不拦截，全部由rad2拦截
	min_cost = min(min_cost, max(max_r2, rad[N-1].d2));
	printf("%d\n", min_cost);

	return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NTYwODMyMjMsMTE3OTUxNDY1MywtMj
EyMDYyNjk0OCwxMTk3Nzc1OTY4LDU4NDE5MTAwOSwtMTc4MDk4
NTQ1NiwzNDM4MTY2NjUsLTEwOTg5MzUxNzksLTE0NTg5MDExNz
EsNzgxNDg0NywxNjI3NjYyMzM4LDE1NTMyNzM1NDJdfQ==
-->