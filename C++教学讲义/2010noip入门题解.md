
## 2010 NOIP 入门组题解

### T2

```c++
// 模拟做法，特别注意：接水停止的条件是，所有水龙头上的同学都接完水了，并且没人排队了

#include<iostream>
// #include<numeric>

using namespace std;

int a[10005], pos[105];

int main(){
	// freopen("P1190_9.in", "r", stdin);
	// freopen("P1190_9.out", "w", stdout);

	int n, m, stop=1, cost=0;
	cin >> n >> m;
	int next = m+1; // 下一个轮到的人

	for(int i=1;i<=n;i++) {
		cin >> a[i];
		if (i<=m) pos[i] = i;
	}

	while(1){
		cost++;
		for(int i=1;i<=m;i++){
			if(a[pos[i]]>0) {
				a[pos[i]]--;
				if(a[pos[i]]>0) stop = 0; // 只要有一个水龙头上的同学还没接完水，就继续模拟接水
			}

			// 排队的人补位接水
			if(a[pos[i]]==0 && next<=n){
				pos[i] = next;
				next++;
				stop = 0; // 有人补位上来，继续模拟接水
			}
		}

		if (stop) break;
		stop = 1;

		// if(accumulate(a+1, a+1+n , 0)==0) break;
	}
	cout << cost << endl;
	return 0;
}
```

```c++
// 贪心做法
#include<iostream>

using namespace std;

int a[10005], pos[105];
// 数组a记录每个人要接水的总量
// 数组pos记录 从第1秒开始接水，到新的排队的人开始接水时，每个水龙头接水的总量（也等于每个水龙头接水的时间）

int main(){
	int n, m;
	cin >> n >> m;
	for(int i=1;i<=n;i++) cin >> a[i];
	
	// 遍历n个人，依次给每个人分配水龙头，让下一个排队的人去接水时间最短的水龙头
	for(int i=1;i<=n;i++){
		int minpos = 1;

		// 遍历m个水龙头，找到接水时间最短的水龙头
		for(int j=2;j<=m;j++){
			if(pos[j]<pos[minpos]) minpos = j;
		}
		pos[minpos] += a[i]; // 让第i个人去minpos水龙头接水，将这个人的接水总量加到minpos水龙头的接水总量中
	}

	// n个人都接完水后，找到总接水时间最长的水龙头
	int maxpos = 1;
	for(int j=2;j<=m;j++){
		if(pos[j]>pos[maxpos]) maxpos = j;
	}
	cout << pos[maxpos] << endl;
	return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI1ODIyNzUwMCwxNTUzMjczNTQyXX0=
-->