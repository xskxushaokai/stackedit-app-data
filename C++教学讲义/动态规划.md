# 动态规划

## 引言
**动态规划** (**Dynamic Programming，DP**) 是算法竞赛中的必考题型，内容丰富多变。
动态规划是地道的“计算思维”，非常适合用计算机实现，可以说是独属于计算机科学的基础理论。与贪心、分治一样，动态规划是一种解题的思路，而不是一个具体的算法知识点。动态规划是一种需要学习才能获得的思维方法。像贪心、分治这样的方法，在生活中和其他学科中有很多类似的例子，很容易联想和理解。但是动态规划不同，它是一种生活中没有的抽象计算方法，没有学过的人很难自发产生这种思路。

## 1. DP概念和编程方法
### 递推回顾
 前面已经学习了递推算法：通过已知的初始条件，利用特定的递推关系，逐步推导出后续的数据或结果。递推算法的核心在于找到问题中数据之间的内在联系，将一个复杂的问题分解为一系列简单的步骤，通过不断重复这些步骤来得到最终的解。

**递推的一般步骤**
递推算法的核心是通过**状态定义**和**递推关系**，将复杂问题分解为子问题的解。关键步骤：
1.  **定义状态**：明确 `f[i]` 或 `f[i][j]` 表示什么。
2.  **推导递推式**：分析当前状态如何由之前的状态转移而来。
3.  **设定初始条件**：确保最小子问题有已知解。
4.  **确定递推顺序**：从小到大或从底向上，避免依赖未计算的状态。  
    通过以上例题可看出，递推广泛应用于计数、最优化、几何等问题，是 OI 竞赛中基础且重要的算法思想。

**以斐波那契数列为例，回顾递推思想**
斐波那契数列是一个递推数列，它的每个数字是前面两个数字的和，如 1，1，2，3，5，8，……，计算第n个斐波那契数，递推公式为：
$$fib(n)=fib(n-1)+fib(n-2)$$
斐波那契数列的应用场景是走楼梯问题：一次可以走一个或两个台阶，问走到第n个台阶时，一共有多少种走法？走楼梯问题的数学模型就是斐波那契数列。要走到第n级台阶，分为两种情况，一种是从n-1级台阶一步走一阶过来，另一种是从n-2级台阶一步跨两阶过来。
实现方式有两种：递归实现 和 递推实现，代码如下：
```c++
// 递归实现
int fib(int n){
	if(n==1 || n==2) return 1;
	return (fib(n-1)+fib(n-2));    // 递归的时间复杂度以2的倍数递增
}
```
代码中的递归数量以2的倍数递增，复杂度为$O(2^n)$，非常差，我们可以使用递推的方式来实现，代码如下：
```c++
// 递推实现
const int N = 255;
int dp[N];
int fib(int n){
	dp[1] = dp[2] = 1;
	for(int i=3;i<=n;i++) dp[i] = dp[i-1] + dp[i-2];
	return dp[n];
}
```
以上两种实现方式中，求解总体问题$fib(n)$的值都依赖于较小的子问题结果，即$fib(n-1)$和$fib(n-2)$，这就是DP的应用场景。

一些问题具有两个特征：**重叠子问题、最优子结构**。用DP可以高效率地处理具有这两个特征地问题。

### 重叠子问题
首先，子问题是原大问题地小版本，计算步骤完全一样；其次，计算大问题时，需要多次重复计算小问题。这就是重叠子问题。以斐波那契数列为例，递归计算$fib(5)$，分解为如图所示的子问题。
![输入图片说明](/imgs/2025-12-22/CfelavzrzqIL4Jr2.png)

其中，$fib(3)$计算了两次，其实只计算一次就够了。

一个子问题的多次重复计算，耗费了大量时间。用DP处理重叠子问题，每个子问题只计算一次，从而避免了重复计算，这就是DP效率高的原因。具体的做法时首先分析得到**最优子结构**，然后用**递推**或带**记忆化搜索的递归**进行编程，从而实现高效的计算。

### 最优子结构
首先，大问题的最优解包含小问题的最优解；其次，可以通过小问题的最优解推导出大问题的最优解。这就是**最优子结构**。在斐波那契数列问题中，把数列的计算构造成 $fib(n) = fib(n-1) + fib(n-2)$，即把原来为 $n$ 的大问题，减小为 $n-1$ 和 $n-2$ 的小问题，这是斐波那契数列的最优子结构。

在 DP 的概念中，还常常提到“**无后效性**”。简单地说，就是“**未来与过去无关**”。此概念不太容易理解，下面以走楼梯问题为例进行解释。要走到第 $n$ 级台阶，有两种方法，一种是从第 $n-1$ 级台阶跨1级台阶过来，另一种是从第 $n-2$ 级台阶跨两级台阶过来。但是，前面是如何走到第 $n-1$ 级或第 $n-2$ 级台阶，$fib(n-1)$ 和 $fib(n-2)$ 是如何计算得到的，并不需要知道，只需要它们的计算结果就行了。换句话说，**只关心前面的结果，不关心前面的过程**，在计算 $fib(n)$ 时，直接使用 $fib(n)$ 和 $fib(n-1)$ 的结果，不需要知道它们的计算过程，这就是无后效性。

**无后效性是应用 DP 的必要条件**，因为只有这样，才能降低算法的复杂度，应用 DP 才有意义。如果不满足无后效性，那么在计算 $fib(n)$ 时，还需要重新计算 $fib(n-1)$ 和 $fib(n-2)$，算法并没有优化。

从最优子结构的概念可以看出，它是满足无后效性的。

这里用斐波那契数列举例说明 DP 的概念，可能过于简单，不足以说明 DP 的特征。建议同学们用后文的“0/1 背包”经典问题重新理解 DP 的特征。

### DP的两种编程方法
处理 DP 中的大问题和小问题，有两种思路：**自顶向下（Top-Down，先大问题，再小问题）、自底向上（Bottom-Up，先小问题，再大问题）**。

编码实现 DP 时，**自顶向下用带记忆化搜索的递归编码，自底向上用递推编码**。两种方法的复杂度是一样的，每个子问题都计算一遍，而且只计算一遍。

#### 自顶向下与记忆化
先考虑大问题，再缩小到小问题，递归很直接地体现了这种思路。为避免递归时重复计算子问题，可以在子问题得到解决时就保存结果，再次需要这个结果时，直接返回保存的结果就可以了。这种存储已经解决的子问题的结果的技术称为**记忆化（Memoization）**。
以斐波那契数列为例，记忆化代码如下：
```c++
int memoize[N];
int fib(int n){
	if(n==1) || n==2) return 1;
	if(memoize[n]!=0) return memoize[n];  // 直接返回结果，不再递归
	memoize[n] = fib(n-1) + fib(n-2);  // 递归计算结果，并记忆
	return memoize[n];
}
```
在这段代码中，一个斐波那契数列只计算一次，所以总复杂度为$O(n)$。

#### 自底向上与制表递推
这种方法与递归的自顶向下相反，避免了用递归编程。自底向上的方法先解决子问题，再递推到大问题，通常通过填写**多维表格**来完成，编码时用若干```for```循环语句填表，根据表中的结果，逐步计算出大问题的解决方案。
用制表法计算斐波那契数列，维护一张一维表dp[ ]，记录自底向上的计算结果，更大的数是前面两个数的和，如下所示。
| dp[1] | dp[2] |dp[3]|dp[4]|dp[5]|dp[6]|dp[7]|dp[8]|……|
|--|--|--|--|--|--|--|--|--|
| 1 | 1 |2|3|5|8|13|21|……|

递推实现的时间复杂度也为$O(n)$。代码略。

### DP状态的设计
在使用动态规划思想设计算法时，需要仔细考虑DP的状态，也就是斐波那契数列中的一维表dp[ ]中存储的值的具体含义。DP的状态可以是一维表，也可以是二维表甚至更高维。状态的设计体现了重叠字问题。

### DP状态转移方程
斐波那契数列中，由$dp[i-1]$和$dp[i-2]$计算得到$dp[i]$的过程就叫做DP的状态转移，状态转移方程即为 $dp[i] = dp[i-1] + dp[i-2]$。状态转移方程体现了最优子结构。

___
___
___


## 2. 简单线性DP


### 例1.  B3637 最长上升子序列

### 题目描述
给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列(Longest Increasing Subsequence, LIS)是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。

### 输入格式
第一行，一个整数 $n$，表示序列长度。
第二行有 $n$ 个整数，表示这个序列。

### 输出格式
一个整数表示答案。

### 输入输出样例 #1
#### 输入 #1
```
6
1 2 4 1 3 4
```

#### 输出 #1
```
4
```

### 说明/提示
分别取出 $1$、$2$、$3$、$4$ 即可。

### 分析
考虑动态规划的两个必要条件，对于所给示例，求整个序列的LIS与求序列前k个元素组成序列的LIS可使用同样的方法，满足**重叠子问题**条件，可通过前n-1个元素序列的LIS推导出n个元素序列的的LIS，且前n-1个元素的LIS计算过程不影响第n个元素加入后的LIS结果，满足**最优子结构**。可使用动态规划求解。

对于所给序列 $a[6]$
|a[0]|a[1]|a[2]|a[3]|a[4]|a[5]|
|--|--|--|--|--|--|
|1|2|4|1|3|4|

当仅考虑 $a[0]$ 时，以a[0]结尾的最长上升序列长度为1，因为此时序列仅有1个元素；

当考虑$a[0]$和$a[1]$时，以a[1]结尾的最长上升序列为 "$1,2$"，长度为2；

当考虑$a[0]、a[1]、a[2]$时，以a[2]结尾的最长上升序列为"$1,2,4$"，长度为3；

当考虑$a[0]、a[1]、a[2]、a[3]$时，a[3]小于前面所有元素，故无法延续之前的任何一个上升序列，以a[3]结尾的最长上升序列为它自身"$1$"，长度为1；

当考虑$a[0]、a[1]、a[2]、a[3]、a[4]$时，将$a[4]$与之前的元素$a[j]$逐一比较，若$a[j]<a[i]$，则$a[i]$可以延续以$a[j]$结尾的上升序列，否则，表明以$a[i]$结尾的最长上升序列为它自身，长度为1；

……

总结上述逐元素判断上升序列的过程，可以得到，将状态 $dp[i]$ 定义为**以第$i$个数为结尾的最长递增子序列的长度**，则状态转移方程为：
$$dp[i]=max(dp[j])+1,\\ (0<j<i, \ A_j<A_i)$$
最后，$max(dp[i])$即为整个序列的LIS长度。

**复杂度分析：** $j$ 在 $[0,i)$ 滑动，复杂度为 $O(n)$; $i$ 的变化范围也为 $O(n)$; 总复杂度为 $O(n^2)$。

代码如下：
```c++
#include<iostream>
using namespace std;
int nums[5005], dp[5005];

// 状态dp[i]定义为以第i个数为结尾的最长递增子序列的长度
// 状态转移方程
// dp[i] = max(1, dp[j] + 1), j∈[0,i) 且 nums[j]<nums[i]

int main(){
    int n, maxlen=0;
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> nums[i];
        dp[i] = 1;
        for(int j=0;j<i;j++){
            if(nums[j]<nums[i]){
                dp[i] = max(dp[i], dp[j]+1);
            }
        }

        maxlen = max(dp[i], maxlen);
    }

    cout << maxlen << endl;
    return 0;
}
```

### 简单线性DP状态转移方程练习

### 例2. 最长公共子序列（Longest Common Subsequece，LCS）
一个给定序列的**子序列**是在该序列中删去若干元素后得到的序列。如: $X = [A, B, C, B, D, A, B]$ 的子序列为：所有$X$的子集(集合中元素按原来在X中的顺序排列)，例如$[A, B, D], [B, C, D, B]$, 等等。

给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的**公共子序列**。**最长公共子序列: 公共子序列中长度最长的子序列。**

**问题描述**: 最长公共子序列问题：给定两个序列X和Y，找出X和Y的一个最长公共子序列。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgwMzg2NTExNiw4NzEwMjY0NTMsLTEwOT
E3MTEzMjEsMTE4OTExOTc4MCwtMzEzNDA0MzMsLTIwNTA5NzMw
Niw4MTU1Nzg2MiwtMTk3NzUwNzA2MiwtMTY0ODIwNzE3OSwtMT
Q0NDYzODE1NCwxNDQ3NTAxNTIyLDE4MTUxMTA0NDIsLTI0MDE1
MDU2LC0yOTgyNjM5NzEsLTUyOTIxODU2MSwtODkwMzExODc5LD
EyNzc2ODM4NjAsLTM3ODU4MDgzNSwtMjA3ODA4NjYwMSwyMDMx
MjA3MjMzXX0=
-->