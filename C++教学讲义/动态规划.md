# 动态规划

## 引言
**动态规划** (**Dynamic Programming，DP**) 是算法竞赛中的必考题型，内容丰富多变。
动态规划是地道的“计算思维”，非常适合用计算机实现，可以说是独属于计算机科学的基础理论。与贪心、分治一样，动态规划是一种解题的思路，而不是一个具体的算法知识点。动态规划是一种需要学习才能获得的思维方法。像贪心、分治这样的方法，在生活中和其他学科中有很多类似的例子，很容易联想和理解。但是动态规划不同，它是一种生活中没有的抽象计算方法，没有学过的人很难自发产生这种思路。

## 1. DP概念和编程方法
### 递推回顾
 前面已经学习了递推算法：通过已知的初始条件，利用特定的递推关系，逐步推导出后续的数据或结果。递推算法的核心在于找到问题中数据之间的内在联系，将一个复杂的问题分解为一系列简单的步骤，通过不断重复这些步骤来得到最终的解。

**递推的一般步骤**
递推算法的核心是通过**状态定义**和**递推关系**，将复杂问题分解为子问题的解。关键步骤：
1.  **定义状态**：明确 `f[i]` 或 `f[i][j]` 表示什么。
2.  **推导递推式**：分析当前状态如何由之前的状态转移而来。
3.  **设定初始条件**：确保最小子问题有已知解。
4.  **确定递推顺序**：从小到大或从底向上，避免依赖未计算的状态。  
    通过以上例题可看出，递推广泛应用于计数、最优化、几何等问题，是 OI 竞赛中基础且重要的算法思想。

**以斐波那契数列为例，回顾递推思想**
斐波那契数列是一个递推数列，它的每个数字是前面两个数字的和，如 1，1，2，3，5，8，……，计算第n个斐波那契数，递推公式为：
$$fib(n)=fib(n-1)+fib(n-2)$$
斐波那契数列的应用场景是走楼梯问题：一次可以走一个或两个台阶，问走到第n个台阶时，一共有多少种走法？走楼梯问题的数学模型就是斐波那契数列。要走到第n级台阶，分为两种情况，一种是从n-1级台阶一步走一阶过来，另一种是从n-2级台阶一步跨两阶过来。
实现方式有两种：递归实现 和 递推实现，代码如下：
```c++
// 递归实现
int fib(int n){
	if(n==1 || n==2) return 1;
	return (fib(n-1)+fib(n-2));    // 递归的时间复杂度以2的倍数递增
}
```
代码中的递归数量以2的倍数递增，复杂度为$O(2^n)$，非常差，我们可以使用递推的方式来实现，代码如下：
```c++
// 递推实现
const int N = 255;
int dp[N];
int fib(int n){
	dp[1] = dp[2] = 1;
	for(int i=3;i<=n;i++) dp[i] = dp[i-1] + dp[i-2];
	return dp[n];
}
```
以上两种实现方式中，求解总体问题$fib(n)$的值都依赖于较小的子问题结果，即$fib(n-1)$和$fib(n-2)$，这就是DP的应用场景。

一些问题具有两个特征：重叠子问题、最优子结构。用DP可以高效率地处理具有这两个特征地问题。

### 重叠子问题
首先，子问题是原大问题地小版本，计算步骤完全一样；其次，计算大问题时，需要多次重复计算小问题。这就是重叠子问题。以斐波那契数列为例，递归计算$fib(5)$，分解为如图所示的子问题。
![输入图片说明](/imgs/2025-12-22/CfelavzrzqIL4Jr2.png)

其中，$fib(3)$计算了两次，其实只计算一次就够了。

一个子问题的多次重复计算，耗费了大量时间。用DP处理重叠子问题，每个子问题只计算一次，从而避免了重复计算，这就是DP效率高的原因。具体的做法时首先分析得到**最优子结构**，然后用**递推**或带**记忆化搜索的递归**进行编程，从而实现高效的计算。

### 最优子结构
首先，大问题的最优解包含小问题的最优解；其次，可以通过小问题的最优解推导出大问题的最优解。这就是**最优子结构**。在斐波那契数列问题中，把数列的计算构造成 $fib(n) = fib(n-1) + fib(n-2)$，即把原来为 $n$ 的大问题，减小为 $n-1$ 和 $n-2$ 的小问题，这是斐波那契数列的最优子结构。

在 DP 的概念中，还常常提到“**无后效性**”。简单地说，就是“**未来与过去无关**”。此概念不太容易理解，下面以走楼梯问题为例进行解释。要走到第 $n$ 级台阶，有两种方法，一种是从第 $n-1$ 级台阶跨1级台阶过来，另一种是从第 $n-2$ 级台阶跨两级台阶过来。但是，前面是如何走到第 $n-1$ 级或第 $n-2$ 级台阶，$fib(n-1)$ 和 $fib(n-2)$ 是如何计算得到的，并不需要知道，只需要它们的计算结果就行了。换句话说，**只关心前面的结果，不关心前面的过程**，在计算 $fib(n)$ 时，直接使用 $fib(n)$ 和 $fib(n-1)$ 的结果，不需要知道它们的计算过程，这就是无后效性。

**无后效性是应用 DP 的必要条件**，因为只有这样，才能降低算法的复杂度，应用 DP 才有意义。如果不满足无后效性，那么在计算 $fib(n)$ 时，还需要重新计算 $fib(n-1)$ 和 $fib(n-2)$，算法并没有优化。

从最优子结构的概念可以看出，它是满足无后效性的。

这里用斐波那契数列举例说明 DP 的概念，可能过于简单，不足以说明 DP 的特征。建议同学们用后文的“0/1 背包”经典问题重新理解 DP 的特征。

### DP的两种编程方法
处理 DP 中的大问题和小问题，有两种思路：**自顶向下（Top-Down，先大问题，再小问题）、自底向上（Bottom-Up，先小问题，再大问题）**。

编码实现 DP 时，**自顶向下用带记忆化搜索的递归编码，自底向上用递推编码**。两种方法的复杂度是一样的，每个子问题都计算一遍，而且只计算一遍。

#### 自顶向下与记忆化
先考虑大问题，再缩小到小问题，递归很直接地体现了这种思路。为避免递归时重复计算子问题，可以在子问题得到解决时就保存结果，再次需要这个结果时，直接返回保存的结果就可以了。这种存储已经解决的子问题的结果的技术称为**记忆化（Memoization）**。
以斐波那契数列为例，记忆化代码如下：
```c++
int memoize[N];
int fib(int n){
	if(n==1) || n==2) return 1;
	if(memoize[n]!=0) return memoize[n];  // 直接返回结果，不再递归
	memoize[n] = fib(n-1) + fib(n-2);  // 递归计算结果，并记忆
	return memoize[n];
}
```
在这段代码中，一个斐波那契数列只计算一次，所以总复杂度为$O(n)$。

#### 自底向上与制表递推
这种方法与递归的自顶向下相反，避免了用递归编程。自底向上的方法先解决子问题，再递推到大问题，通常通过填写**多维表格**来完成，编码时用若干```for```循环语句填表，根据表中的结果，逐步计算出大问题的解决方案。
用制表法计算斐波那契数列，维护一张一维表dp[ ]，记录自底向上的计算结果，更大的数是前面两个数的和，如下所示。
| dp[1] | dp[2] |dp[3]|dp[4]|dp[5]|dp[6]|dp[7]|dp[8]|……|
|--|--|--|--|--|--|--|--|--|
| 1 | 1 |2|3|5|8|13|21|……|

递推实现的时间复杂度也为$O(n)$。代码略。

___
___
___


## 2. 简单线性动态规划


### 例1.  B3637 最长上升子序列

### 题目描述
给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。

### 输入格式
第一行，一个整数 $n$，表示序列长度。
第二行有 $n$ 个整数，表示这个序列。

### 输出格式
一个整数表示答案。

### 输入输出样例 #1
#### 输入 #1
```
6
1 2 4 1 3 4
```

#### 输出 #1
```
4
```

### 说明/提示
分别取出 $1$、$2$、$3$、$4$ 即可。
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzk0Mzc5NTc2LC01MjkyMTg1NjEsLTg5MD
MxMTg3OSwxMjc3NjgzODYwLC0zNzg1ODA4MzUsLTIwNzgwODY2
MDEsMjAzMTIwNzIzMyw4NzM4MzA3OCw2NTY5NjExNDAsODQyNz
c5NjM2LC00NTUwNTA2MjUsNDAzMjAxMTg5LC0yMDQ5MDgyNjg3
LDE3MDYzODI1NTQsLTIwMDg0ODIyNDAsLTIxNDM1NDU3NzgsMT
E5NTUxMTI4XX0=
-->