# 动态规划

## 引言
**动态规划** (**Dynamic Programming，DP**) 是算法竞赛中的必考题型，内容丰富多变。
动态规划是地道的“计算思维”，非常适合用计算机实现，可以说是独属于计算机科学的基础理论。与贪心、分治一样，动态规划是一种解题的思路，而不是一个具体的算法知识点。动态规划是一种需要学习才能获得的思维方法。像贪心、分治这样的方法，在生活中和其他学科中有很多类似的例子，很容易联想和理解。但是动态规划不同，它是一种生活中没有的抽象计算方法，没有学过的人很难自发产生这种思路。

## 1. DP概念和编程方法
### 递推回顾
 前面已经学习了递推算法：通过已知的初始条件，利用特定的递推关系，逐步推导出后续的数据或结果。递推算法的核心在于找到问题中数据之间的内在联系，将一个复杂的问题分解为一系列简单的步骤，通过不断重复这些步骤来得到最终的解。

**递推的一般步骤**
递推算法的核心是通过**状态定义**和**递推关系**，将复杂问题分解为子问题的解。关键步骤：
1.  **定义状态**：明确 `f[i]` 或 `f[i][j]` 表示什么。
2.  **推导递推式**：分析当前状态如何由之前的状态转移而来。
3.  **设定初始条件**：确保最小子问题有已知解。
4.  **确定递推顺序**：从小到大或从底向上，避免依赖未计算的状态。  
    通过以上例题可看出，递推广泛应用于计数、最优化、几何等问题，是 OI 竞赛中基础且重要的算法思想。

**以斐波那契数列为例，回顾递推思想**
斐波那契数列是一个递推数列，它的每个数字是前面两个数字的和，如 1，1，2，3，5，8，……，计算第n个斐波那契数，递推公式为：
$$fib(n)=fib(n-1)+fib(n-2)$$
斐波那契数列的应用场景是走楼梯问题：一次可以走一个或两个台阶，问走到第n个台阶时，一共有多少种走法？走楼梯问题的数学模型就是斐波那契数列。要走到第n级台阶，分为两种情况，一种是从n-1级台阶一步走一阶过来，另一种是从n-2级台阶一步跨两阶过来。
实现方式有两种：递归实现 和 递推实现，代码如下：
```c++
// 递归实现
int fib(int n){
	if(n==1 || n==2) return 1;
	return (fib(n-1)+fib(n-2));    // 递归的时间复杂度以2的倍数递增
}
```
代码中的递归数量以2的倍数递增，复杂度为$O(2^n)$，非常差，我们可以使用递推的方式来实现，代码如下：
```c++
// 递推实现
const int N = 255;
int dp[N];
int fib(int n){
	dp[1] = dp[2] = 1;
	for(int i=3;i<=n;i++) dp[i] = dp[i-1] + dp[i-2];
	return dp[n];
}
```
以上两种实现方式中，求解总体问题$fib(n)$的值都依赖于较小的子问题结果，即$fib(n-1)$和$fib(n-2)$，这就是DP的应用场景。

一些问题具有两个特征：**重叠子问题、最优子结构**。用DP可以高效率地处理具有这两个特征地问题。

### 重叠子问题
首先，子问题是原大问题地小版本，计算步骤完全一样；其次，计算大问题时，需要多次重复计算小问题。这就是重叠子问题。以斐波那契数列为例，递归计算$fib(5)$，分解为如图所示的子问题。
![输入图片说明](/imgs/2025-12-22/CfelavzrzqIL4Jr2.png)

其中，$fib(3)$计算了两次，其实只计算一次就够了。

一个子问题的多次重复计算，耗费了大量时间。用DP处理重叠子问题，每个子问题只计算一次，从而避免了重复计算，这就是DP效率高的原因。具体的做法时首先分析得到**最优子结构**，然后用**递推**或带**记忆化搜索的递归**进行编程，从而实现高效的计算。

### 最优子结构
首先，大问题的最优解包含小问题的最优解；其次，可以通过小问题的最优解推导出大问题的最优解。这就是**最优子结构**。在斐波那契数列问题中，把数列的计算构造成 $fib(n) = fib(n-1) + fib(n-2)$，即把原来为 $n$ 的大问题，减小为 $n-1$ 和 $n-2$ 的小问题，这是斐波那契数列的最优子结构。

在 DP 的概念中，还常常提到“**无后效性**”。简单地说，就是“**未来与过去无关**”。此概念不太容易理解，下面以走楼梯问题为例进行解释。要走到第 $n$ 级台阶，有两种方法，一种是从第 $n-1$ 级台阶跨1级台阶过来，另一种是从第 $n-2$ 级台阶跨两级台阶过来。但是，前面是如何走到第 $n-1$ 级或第 $n-2$ 级台阶，$fib(n-1)$ 和 $fib(n-2)$ 是如何计算得到的，并不需要知道，只需要它们的计算结果就行了。换句话说，**只关心前面的结果，不关心前面的过程**，在计算 $fib(n)$ 时，直接使用 $fib(n)$ 和 $fib(n-1)$ 的结果，不需要知道它们的计算过程，这就是无后效性。

**无后效性是应用 DP 的必要条件**，因为只有这样，才能降低算法的复杂度，应用 DP 才有意义。如果不满足无后效性，那么在计算 $fib(n)$ 时，还需要重新计算 $fib(n-1)$ 和 $fib(n-2)$，算法并没有优化。

从最优子结构的概念可以看出，它是满足无后效性的。

这里用斐波那契数列举例说明 DP 的概念，可能过于简单，不足以说明 DP 的特征。建议同学们用后文的“0/1 背包”经典问题重新理解 DP 的特征。

### DP的两种编程方法
处理 DP 中的大问题和小问题，有两种思路：**自顶向下（Top-Down，先大问题，再小问题）、自底向上（Bottom-Up，先小问题，再大问题）**。

编码实现 DP 时，**自顶向下用带记忆化搜索的递归编码，自底向上用递推编码**。两种方法的复杂度是一样的，每个子问题都计算一遍，而且只计算一遍。

#### 自顶向下与记忆化
先考虑大问题，再缩小到小问题，递归很直接地体现了这种思路。为避免递归时重复计算子问题，可以在子问题得到解决时就保存结果，再次需要这个结果时，直接返回保存的结果就可以了。这种存储已经解决的子问题的结果的技术称为**记忆化（Memoization）**。
以斐波那契数列为例，记忆化代码如下：
```c++
int memoize[N];
int fib(int n){
	if(n==1) || n==2) return 1;
	if(memoize[n]!=0) return memoize[n];  // 直接返回结果，不再递归
	memoize[n] = fib(n-1) + fib(n-2);  // 递归计算结果，并记忆
	return memoize[n];
}
```
在这段代码中，一个斐波那契数列只计算一次，所以总复杂度为$O(n)$。

#### 自底向上与制表递推
这种方法与递归的自顶向下相反，避免了用递归编程。自底向上的方法先解决子问题，再递推到大问题，通常通过填写**多维表格**来完成，编码时用若干```for```循环语句填表，根据表中的结果，逐步计算出大问题的解决方案。
用制表法计算斐波那契数列，维护一张一维表dp[ ]，记录自底向上的计算结果，更大的数是前面两个数的和，如下所示。
| dp[1] | dp[2] |dp[3]|dp[4]|dp[5]|dp[6]|dp[7]|dp[8]|……|
|--|--|--|--|--|--|--|--|--|
| 1 | 1 |2|3|5|8|13|21|……|

递推实现的时间复杂度也为$O(n)$。代码略。

### DP状态的设计
在使用动态规划思想设计算法时，需要仔细考虑DP的状态，也就是斐波那契数列中的一维表dp[ ]中存储的值的具体含义。DP的状态可以是一维表，也可以是二维表甚至更高维。状态的设计体现了重叠字问题。

### DP状态转移方程
斐波那契数列中，由$dp[i-1]$和$dp[i-2]$计算得到$dp[i]$的过程就叫做DP的状态转移，状态转移方程即为 $dp[i] = dp[i-1] + dp[i-2]$。状态转移方程体现了最优子结构。

___
___
___


## 2. 简单线性DP


### 例1.  B3637 最长上升子序列

### 题目描述
给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列(Longest Increasing Subsequence, LIS)是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。

### 输入格式
第一行，一个整数 $n$，表示序列长度。
第二行有 $n$ 个整数，表示这个序列。

### 输出格式
一个整数表示答案。

### 输入输出样例 #1
#### 输入 #1
```
6
1 2 4 1 3 4
```

#### 输出 #1
```
4
```

### 说明/提示
分别取出 $1$、$2$、$3$、$4$ 即可。

### 分析
考虑动态规划的两个必要条件，对于所给示例，求整个序列的LIS与求序列前k个元素组成序列的LIS可使用同样的方法，满足**重叠子问题**条件，可通过前n-1个元素序列的LIS推导出n个元素序列的的LIS，且前n-1个元素的LIS计算过程不影响第n个元素加入后的LIS结果，满足**最优子结构**。可使用动态规划求解。

对于所给序列 $a[6]$
|a[0]|a[1]|a[2]|a[3]|a[4]|a[5]|
|--|--|--|--|--|--|
|1|2|4|1|3|4|

当仅考虑 $a[0]$ 时，以a[0]结尾的最长上升序列长度为1，因为此时序列仅有1个元素；

当考虑$a[0]$和$a[1]$时，以a[1]结尾的最长上升序列为 "$1,2$"，长度为2；

当考虑$a[0]、a[1]、a[2]$时，以a[2]结尾的最长上升序列为"$1,2,4$"，长度为3；

当考虑$a[0]、a[1]、a[2]、a[3]$时，a[3]小于前面所有元素，故无法延续之前的任何一个上升序列，以a[3]结尾的最长上升序列为它自身"$1$"，长度为1；

当考虑$a[0]、a[1]、a[2]、a[3]、a[4]$时，将$a[4]$与之前的元素$a[j]$逐一比较，若$a[j]<a[i]$，则$a[i]$可以延续以$a[j]$结尾的上升序列，否则，表明以$a[i]$结尾的最长上升序列为它自身，长度为1；

……

总结上述逐元素判断上升序列的过程，可以得到，将状态 $dp[i]$ 定义为**以第$i$个数为结尾的最长递增子序列的长度**，则状态转移方程为：
$$dp[i]=max(dp[j])+1,\\ (0<j<i, \ A_j<A_i)$$
最后，$max(dp[i])$即为整个序列的LIS长度。

**复杂度分析：** $j$ 在 $[0,i)$ 滑动，复杂度为 $O(n)$; $i$ 的变化范围也为 $O(n)$; 总复杂度为 $O(n^2)$。

代码如下：
```c++
#include<iostream>
using namespace std;
int nums[5005], dp[5005];

// 状态dp[i]定义为以第i个数为结尾的最长递增子序列的长度
// 状态转移方程
// dp[i] = max(1, dp[j] + 1), j∈[0,i) 且 nums[j]<nums[i]

int main(){
    int n, maxlen=0;
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> nums[i];
        dp[i] = 1;
        for(int j=0;j<i;j++){
            if(nums[j]<nums[i]){
                dp[i] = max(dp[i], dp[j]+1);
            }
        }

        maxlen = max(dp[i], maxlen);
    }

    cout << maxlen << endl;
    return 0;
}
```

### 简单线性DP状态转移方程练习

### 例2. 最长公共子序列（Longest Common Subsequece，LCS）
一个给定序列的**子序列**是在该序列中删去若干元素后得到的序列。如: $X = [A, B, C, B, D, A, B]$ 的子序列为：所有$X$的子集(集合中元素按原来在X中的顺序排列)，例如$[A, B, D], [B, C, D, B]$, 等等。

给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的**公共子序列**。**最长公共子序列: 公共子序列中长度最长的子序列。**

**问题描述**: 最长公共子序列问题：给定两个序列X和Y，找出X和Y的一个最长公共子序列。
例如：$X = [A, B, C, B, D, A, B]$ ,  $Y = [B, D, C, A, B, A]$， 则$[B, C, B, A]$和$[B, D, A, B]$都是X和Y 的最长公共子序列（长度为4）。
请写出动态规划求两序列最长公共子序列长度的状态转移方程。

#### 解析
**方法一：暴力法**
对于每一个 $X=[x_1,x_2,…,x_m]$ 的子序列，验证它是否是 $Y=[y_1,y_2,…, y_n]$ 的子序列。
$X$ 有 $2^m$ 个子序列。（为什么？）
每个子序列需要 $O(n)$ 的时间来验证它是否是$Y$ 的子序列：从$Y$的第一个字母开始扫描，如果不是则从第二个开始。
运行时间:$O(n2^m$)。

**方法二：DP**
从$X$和$Y$的最后一个元素往前递推，分两种情况讨论：
1. 当$x_m=y_n$时，找出$X_{m-1}$和$Y_{n-1}$的最长公共子序列，然后在其尾部加上$x_m$即可得到$X$和$Y$的最长公共子序列；
2. 当$x_m≠y_n$时，求解两个子问题：（1）找出$X_{m-1}$和$Y_n$的最长公共子序列；（2）$X_m$和$Y_{n-1}$的最长公共子序列。这两个公共子序列中的较长者即为$X$和$Y$的最长公共子序列。

用$L[i][j]$表示子序列$X_i$和$Y_j$的最长公共子序列的长度，动态规划函数：
$$L[0][0]=L[i][0]=L[0][j]=0 \space\space\space\space (1≤i≤m,1≤j≤n)$$
$$L[i][j] = \begin{cases} L[i-1][j-1]+1 &\text{if } x_i=y_j,i>1,j>1 \\ max(L[i][j-1], L[i-1][j]) &\text{if } x_i≠y_j,i>1,j>1 \end{cases}$$

<br><br>



### 例3. 编辑距离（Edit Distance）
**问题描述**: 设 A 和 B 是两个字符串，均只包含小写字母。我们要用最少的字符操作次数，将字符串 A 转换为字符串 B。这里所说的字符操作共有三种：
	1. 删除一个字符；
	2. 插入一个字符；
	2. 将一个字符改为另一个字符。


**输入**：第一行为字符串 A；第二行为字符串 B；字符串 A,B 的长度均小于 2000。
**输出**：只有一个正整数，为最少字符操作次数。

**示例输入**
```
sfdqxbw
gfdgw
```
**示例输出**
```
4
```


#### 解析
为方便理解，把长度为$m$的A存储在数组 $word1[1]$ \~ $word1[m]$，把长度为$n$的B存储在数组$word2[1]$ \~ $word2[n]$，不使用 $word1[0]$ 和 $word2[0]$ 。

定义二维数组 $dp$，$dp[i][j]$ 表示从word1的前 $i$ 个字符转换到word2的前 $j$ 个字符所需的操作步骤数，则 $dp[m][n]$ 就是答案。

逆向考虑最后一个字符，有两种情况：
1. 若 $word1[i]==word2[j]$，则 $dp[i][j] = dp[i-1][j-1]$；

2. 其他情况，$dp[i][j]=min\{dp[i-1][j-1], dp[i-1][j], dp[i][j-1]\} + 1$ ，分别对应了以下 3 种操作：

 (1). $dp[i-1][j]+1$，将$word1$的前 $i-1$ 个字符转换为 $word2$ 的前j个字符，并将$word1$ 的第 $i$ 个字符删去；
 
 (2). $dp[i][j-1]+1$，将$word1$的前 $i$个字符转换为$word2$的前 $j-1$ 个字符，并在$word1$的最后插入$word2[j]$；
 
 (3). $dp[i-1][j-1]+1$，将$word1$的前 $i-1$ 个字符转换为$word2$的前 $j-1$ 个字符，并将 $word1[i]$ 修改为 $word2[j]$ 。

<br><br>




### 例4. 0/1背包问题
**问题描述**: 给定$N$ 个物品和一个背包，第$i$ 个物品的体积为$c_i$，价值为$w_i$，背包的总容量为$C$。把物品装入背包时，第$i$ 个物品只有两种选择：装入背包或不装入背包。此问题称为0/1背包问题。如何选择装入背包的物品，使装入背包中的物品总价值最大？写出DP状态转移方程。

设$x_i$表示物品$i$ 装入背包的情况：$x_i=0$ 时，不装入背包；$x_i=1$ 时，装入背包。则问题可抽象为如下数学模型：
$$约束条件：\sum_{i=1}^Nc_ix_i \leqslant C, \space \space x_i=0,1$$
$$目标函数：max\sum_{i=1}^Nw_ix_i$$

####  解析
引入一个$(N+1)*(C+1)$的二维数组```dp[][]```，称为DP状态，```dp[i][j]```表示把前$i$个物品（从第1个到第i个）装入容量为 $j$ 的背包中获得的最大值。可以把每个```dp[i][j]```都看作一个背包：背包的容量为 $j$，装入 ```1 ~ i```这些物品。最后```dp[N][C]```就是问题的答案。

如何求```dp[i][j]```，也就是，把前$i$个物品装入容量为 $j$ 的背包中获得的最大价值是多少？我们从最后一个物品 $i$ 入手，可以分为两种情况：

(1). 第 $i$ 个物品的体积比背包容量 $j$ 还大，无法装入，则直接继承前 $i-1$ 个物品装入容量为 $j$ 的背包的情况即可，即 $dp[i][j]=dp[i-1][j]$ 。

(2). 第 $i$ 个物品的体积比容量 $j$ 小，能装进背包。又可以进一步分为两种情况：装或不装第 $i$ 个物品。
 - a. 装第 $i$ 个物品。第 $i$ 个物品装进背包后，背包的剩余容量减少 $c[i]$，价值增加 $w[i]$ ，则背包剩余的空间 $j-c[i]$ 可以考虑继续装前 $i-1$ 个物品，故有 $dp[i][j]=dp[i-1][j-c[i]] + w[i]$ 。
 - b. 不装第i个物品，则背包的空间 $j$ 全部用来装前 $i-1$ 个物品，有 $dp[i][j]=dp[i-1][j]$ 。

取 a、b 两种情况的最大值，状态转移方程即为：
$$dp[i][j] = max(dp[i-1][j], dp[i-1][j-c[i]]+w[i])$$

综合(1)(2)两种情形，最终的状态转移方程为：
$$dp[i][j] = \begin{cases} dp[i-1][j] &\text{if } c_i>j,i>0,j>0 \\ max(dp[i-1][j], dp[i-1][j-c[i]]+w[i]) &\text{if } c_i<=j,i>0,j>0 \end{cases}$$

初始状态：$dp[i][0]=dp[0][j]=0$


<br><br>

### 总结：线性DP解题的两个要点
#### 1. 确定子问题的划分方式，即确定状态如何表示
通常，根据输入变量数来确定状态数组的维度
#### 2. 确定子问题的求解方式，即状态转移方程
子问题求解的一般套路为：1.分情况讨论（即加法原理，如斐波那契数列）；2.求最值（分情况后，取不同情况的最值（最大/最小）作为最终结果）


## 3. 滚动数组优化DP

滚动数组是 DP 最常用的空间优化技术。 

DP 的状态方程常常是二维和二维以上，占用了太多空间。例如，5.1.3 节的代码使用了二维矩阵 `int dp[N][C]`，设 $N=10^3, C=10^4$，都不算大，但 int 型占据 4B，矩阵需要的空间为 $4 \times 10^3 \times 10^4 \approx 40\text{MB}$，已经超过一般竞赛题的空间限制。 

用滚动数组可以大大减少空间。它能把二维状态方程 $O(n^2)$ 的空间复杂度优化到一维的 $O(n)$，更高维的数组也可以优化后减少一维。

----------

### 第二页：交替滚动与自我滚动

从状态转移方程 $dp[i][j] = \max(dp[i-1][j], dp[i-1][j-c[i]] + w[i])$ 可以看出，$dp[i][j]$ 只与 $dp[i-1][]$ 有关，和前面的 $dp[i-2][], dp[i-3][], \dots$ 都没有关系。从前面的图表也可以看出，每行是通过上面一行算出来的，与更前面的行没有关系。那些用过的已经无用的 $dp[i-2][], dp[i-3][], \dots$ 多余了，那么干脆就复用这些空间，用新的一行覆盖已经无用的一行（滚动），只需要两行就够了。 下面给出滚动数组的两种实现方法，两种实现方法都很常用。

#### 1. 交替滚动

定义 $dp[2][j]$，用 $dp[0][]$ 和 $dp[1][]$ 交替滚动。这种方法的优点是逻辑清晰，编码不容易出错，建议初学者采用这种方法。 下面的代码中，`now` 始终指向正在计算的最新的一行，`old` 指向已计算过的旧的一行。对照原递推代码，`now` 相当于 $i$，`old` 相当于 $i-1$。

```cpp
// hdu 2602 (滚动数组代码 1)
int dp[2][N];
int solve(int n, int C){
    int now = 0, old = 1;
    for(int i = 1; i <= n; i++){
        swap(old, now); // 交替滚动，now 始终指向最新的一行
        for(int j = 0; j <= C; j++){
            if(c[i] > j) dp[now][j] = dp[old][j];
            else         dp[now][j] = max(dp[old][j], dp[old][j-c[i]] + w[i]);
        }
    }
    return dp[now][C]; // 返回最新的一行
}
```

注意，$j$ 循环是 $0 \sim C$，其实反过来也可以。但是在下面的“自我滚动”代码中，必须反过来循环，即 $C \sim 0$。

#### 2. 自我滚动

用两行做交替滚动在逻辑上很清晰，但是还能继续精简：一维 $dp[]$ 就够了，自己滚动自己。

```cpp
// hdu 2602 (滚动数组代码 2)
int dp[N];
int solve(int n, int C){
    for(int i = 1; i <= n; i++){
        for(int j = C; j >= c[i]; j--) // 反过来循环
            dp[j] = max(dp[j], dp[j-c[i]] + w[i]);
    }
    return dp[C];
}
```

注意，$j$ 应该反过来循环，即从后向前覆盖。下面说明原因，用 $dp[j]'$ 表示旧状态，$dp[j]$ 表示滚动后的新状态。

----------

### 第三页：原理分析与分组背包

(1) **$j$ 从小到大循环是错误的。** 例如，$i=2$ 时，图 5.8 左侧的 $dp[5]$，经计算得到 $dp[5]=9$，把 $dp[5]$ 更新为 9。继续计算，当计算 $dp[8]$ 时，得 $dp[8]=dp[5]'+3 = 9+3=12$，这个答案是错的。错误的产生是由滚动数组重复使用同一个空间引起的。 _(图 5.8 略：展示了 $j$ 从小到大导致同一物品被多次放入)_

(2) **$j$ 从大到小循环是对的。** 例如，$i=2$ 时，首先计算最后的 $dp[9]=9$，它不影响前面状态的计算，如图 5.9 所示。 _(图 5.9 略：展示了 $j$ 从大到小保证了使用的是上一轮的状态)_

经过交替滚动或自我滚动的优化，DP 的空间复杂度从 $O(N \times C)$ 降低到 $O(C)$。

**提示：** 滚动数组也有缺点。它覆盖了中间转移状态，只留下了最后的状态，所以丢失了很多信息，导致无法输出具体的方案。

二维以上的 $dp$ 数组也能优化。例如，求 $dp[t][][]$，如果它只和 $dp[t-1][][]$ 有关，不需要 $dp[t-2][][], dp[t-3][][]$ 等，那么可以把数组缩小为 $dp[2][][]$ 或 $dp[][]$。

----------

### 5.2 经典线性 DP 问题

**1. 分组背包** （手写笔记：组内物品互斥） 有一些物品，把物品分为 $n$ 组，其中第 $i$ 组第 $k$ 个物品的体积为 $c[i][k]$，价值为 $w[i][k]$；每组内的物品冲突，每组内最多只能选出一个物品装进背包；给定一个容量为 $C$ 的背包，问如何选物品，使装进背包的物品的总价值最大。 解题思路与 0/1 背包问题很相似。回顾 0/1 背包问题的状态定义...（图片截断）
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU2ODMxNDI2NiwxMTk4NTMyOTA2LDE1Mz
kxNzgyNzUsNjc0MzE2MDIzLDMyMTkyMDcyMCwtMzU0Mjc5NDY3
LDE3ODYzMzY2NzMsLTE1NzY0NjM3MjksNTY4OTA1NzQsLTExMD
A5OTg2MTYsMjEyODAxNjA0LC04NTg4Mjg2NTcsLTQ0MjE4ODMw
MywtMTI1MDUyMDQsMTEwODY1ODkwMywtMTkwMTU4Mjk4OSwtMj
EwMzQxNDMzNiwxMzE4NTk5NDA5LDExNTY1NzM4NTYsLTQyMzc0
MzI1OV19
-->